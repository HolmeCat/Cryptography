#include <iostream>
#include <string>
#include <memory.h>
#include <cstdio>
using namespace std;
const static char IP[64] = //初始置换
{
	58, 50, 42, 34, 26, 18, 10, 2,
	60, 52, 44, 36, 28, 20, 12, 4,
	62, 54, 46, 38, 30, 22, 14, 6,
	64, 56, 48, 40, 32, 24, 16, 8,
	57, 49, 41, 33, 25, 17,  9, 1,
	59, 51, 43, 35, 27, 19, 11, 3,
	61, 53, 45, 37, 29, 21, 13, 5,
	63, 55, 47, 39, 31, 23, 15, 7
};
const static char EP1[56] = //密钥置换（原64位去掉奇偶校验位后）
{
	57, 49, 41, 33, 25, 17, 9,
	 1, 58, 50, 42, 34, 26, 18,
	10,  2, 59, 51, 43, 35, 27,
	19, 11,  3, 60, 52, 44, 36,
	63, 55, 47, 39, 31, 23, 15,
	 7, 62, 54, 46, 38, 30, 22,
	14,  6, 61, 53, 45, 37, 29,
	21, 13,  5, 28, 20, 12, 4
};
const static char LOOP[16] = //左移
{
  1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1
};
const static char EP2[48] = //选择子密钥
{
  14, 17, 11, 24,  1,  5,
   3, 28, 15,  6, 21, 10,
  23, 19, 12,  4, 26,  8,
	16,  7, 27, 20, 13,  2,
	41, 52, 31, 37, 47, 55,
	30, 40, 51, 45, 33, 48,
	44, 49, 39, 56, 34, 53,
	46, 42, 50, 36, 29, 32
};
static const char EC[48] = //放大换位
{
  32,  1,  2,  3,  4,  5,
   4,  5,  6,  7,  8,  9,
   8,  9, 10, 11, 12, 13,
  12, 13, 14, 15, 16, 17,
  16, 17, 18, 19, 20, 21,
  20, 21, 22, 23, 24, 25,
  24, 25, 26, 27, 28, 29,
  28, 29, 30, 31, 32,  1
};
const static char SBox[8][4][16] = //8个S盒
{
  {
    // S1
    {  14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7   },
    {   0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8   },
    {   4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0   },
    {  15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13   }
  },
  {
    // S2
    {  15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10   },
    {   3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5   },
    {   0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15   },
    {  13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9   }
  },
  {
    // S3
    {  10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8   },
    {  13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1   },
    {  13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7   },
    {   1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12   }
  },
  {
    // S4
    {   7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15   },
    {  13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9   },
    {  10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4   },
    {   3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14   }
  },
  {
    // S5
    {   2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9   },
    {  14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6   },
    {   4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14   },
    {  11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3   }
  },
  {
    // S6
    {  12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11   },
    {  10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8   },
    {   9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6   },
    {   4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13   }
  },
  {
    // S7
    {   4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1   },
    {  13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6   },
    {   1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2   },
    {   6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12   }
  },
  {
    // S8
    {  13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7   },
    {   1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2   },
    {   7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8   },
    {   2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11   }
  }
};
const static char PP[32] = //P盒置换
{
	16,  7, 20, 21, 29, 12, 28, 17,
	 1, 15, 23, 26,  5, 18, 31, 10,
	 2,  8, 24, 14, 32, 27,  3,  9,
	19, 13, 30,  6, 22, 11,  4, 25,
};
const static char LP[64] = //末置换
{
	40, 8, 48, 16, 56, 24, 64, 32,
	39, 7, 47, 15, 55, 23, 63, 31,
	38, 6, 46, 14, 54, 22, 62, 30,
	37, 5, 45, 13, 53, 21, 61, 29,
	36, 4, 44, 12, 52, 20, 60, 28,
	35, 3, 43, 11, 51, 19, 59, 27,
	34, 2, 42, 10, 50, 18, 58, 26,
	33, 1, 41,  9, 49, 17, 57, 25
};
static bool M[64],tmp[32], *Li = &M[0], *Ri = &M[32];
static bool SubKey[16][48];//16个子密钥
class CDES{ //定义DES类
private:
    void f(int e){ //加密f函数，e代表加密还是解密
        int i,j;
        bool MEC[48];
        bool MS[32];
        bool MP[32];
        for(i=0;i<16;i++) { //16轮迭代f函数
          for(j=0;j<48;j++) //放大变换48位
            MEC[j] = Ri[EC[j]-1];
          for(j=0;j<48;j++){ //MEC[j]和SubKey[i][j]进行异或
            if(e == 0) //加密
                MEC[j] ^= SubKey[i][j];
            else //解密
                MEC[j] ^= SubKey[15-i][j];
          }
          for(j=0;j<8;j++){ //S盒置换，每个S盒对应之前的每6位
            int r,c; //r为S盒行号，c为S盒列号
            r = MEC[j*6] * 2 + MEC[j*6+5] * 1; //计算行号，第0位第5位
            c = MEC[j*6+1] * 8 + MEC[j*6+2] * 4 + MEC[j*6+3] * 2 + MEC[j*6+4] * 1; //计算列号，中间4位构成
            //处理S盒结果十进制转二进制存入MP的j*4到j*4+3位
            //比如S1盒的3，就存入MP的0到3位为 0 0 1 1
            int ms = SBox[j][r][c]; //这是十进制的MS
            for(int k=j*4+3;k>=j*4;k--){ //转换为二进制
              MS[k] = ms % 2;
              ms /= 2;
            }
            //至此一个S盒的处理完毕，生成了4个01位在MP中
          }
          for(j=0;j<32;j++) //P盒置换
            MP[j] = MS[PP[j]-1];
          //左右交换 + Li异或MP操作
          memcpy(tmp,Ri,32);
          for(j=0;j<32;j++) //
              Ri[j] = MP[j] ^ Li[j];
          memcpy(Li,tmp,32);
          if(i == 15){ //最后一轮再换回来
            memcpy(tmp,Ri,32);
            memcpy(Ri,Li,32);
            memcpy(Li,tmp,32);
          }
        }
        //核心f函数执行完毕，此时M是没有经过逆置换的结果
        return;
    }
public:
    //void Mode();//模式
    void createKey(char key[8]){ //生成16组密钥
        int i,j,k;
        //将字符密钥key转换为二进制存入K
        bool K[64];
        for(i=0;i<8;i++){
          K[(i+1)*8-1] = key[i] & 1;//取出0位
          for(j=1;j<8;j++)
            K[(i+1)*8-1-j] = (key[i] >> j) & 1;//取出j位,用1做与运算掩码就行
        }
        bool KEP[56];
        for(i=0;i<56;i++) //EP1置换
          KEP[i] = K[EP1[i]-1];
        for(i=0;i<16;i++){ //左移Loop[i]位
          for(j=0;j<LOOP[i];j++){
            bool temp;
            temp = KEP[0];
            for(k=1;k<28;k++) //左移左侧1位
              KEP[k-1] = KEP[k];
            KEP[27] = temp;
            temp = KEP[28];
            for(k=29;k<56;k++) //左移右侧1位
              KEP[k-1] = KEP[k];
            KEP[55] = temp;
          }
          for(j=0;j<48;j++) //EP2形成Subkey[i]
            SubKey[i][j] = KEP[EP2[j]-1];
        }
        return;
    }
    void Encryption(char out[8],char In[8]){ //加密函数
        int i,j;
        //In转换为二进制存入M
        for(i=0;i<8;i++){
          M[(i+1)*8-1] = In[i] & 1;//取出0位
          for(j=1;j<8;j++)
            M[(i+1)*8-1-j] = (In[i] >> j) & 1;//取出j位,用1做与运算掩码就行
        }
        bool mTemp[64]; //64位中间变量
        memcpy(mTemp,M,64);
        //初始置换
        for(i=0;i<64;i++) //IP置换
          M[i] = mTemp[IP[i]-1];
        f(0);//16轮f函数
        //最后针对M进行一个LP末置换
        memcpy(mTemp,M,64);
        for(i=0;i<64;i++) //LP也就是IP逆置换
          M[i] = mTemp[LP[i]-1];
        //M转换为char存入out
        for(i=0;i<64;i++) //i/8代表第几个，i%8代表第几位
            out[i/8] |= (M[i] << (7-(i%8))); //左移之后然后或运算
        return;
    }
    void Decryption(char out[8],char In[8]){ //解密函数
        int i,j;
        //In转换为二进制存入M
        for(i=0;i<8;i++){
          M[(i+1)*8-1] = In[i] & 1;//取出0位
          for(j=1;j<8;j++)
            M[(i+1)*8-1-j] = (In[i] >> j) & 1;//取出j位,用1做与运算掩码就行
        }
        bool mTemp[64]; //64位中间变量
        memcpy(mTemp,M,64);
        //初始置换
        for(i=0;i<64;i++) //IP置换
          M[i] = mTemp[IP[i]-1];
        f(1);//16轮f函数
        //最后针对M进行一个LP末置换
        memcpy(mTemp,M,64);
        for(i=0;i<64;i++) //LP也就是IP逆置换
          M[i] = mTemp[LP[i]-1];
        //M转换为char存入out
        for(i=0;i<64;i++) //i/8代表第几个，i%8代表第几位
            out[i/8] |= (M[i] << (7-(i%8))); //左移之后然后或运算
        return;
    }
};
int main(){ //主函数
    CDES cDes;
    char In[8];memset(In,0,sizeof(In));
    char out[8];memset(out,0,sizeof(out));
    char key[8];memset(key,0,sizeof(key));
    //读入最多8个字符
    int i;char c;
    cout << "请输入要加密的字符：";
    c = getchar();
    for(i=0;c != '\n';i++){
      In[i] = c;
      c = getchar();
    }
    //读入加密密码
    cout << "请设置加密密码：";
    c = getchar();
    for(i=0;c != '\n';i++){
      key[i] = c;
      c = getchar();
    }
    //加密演示
    cDes.createKey(key);
    cDes.Encryption(out,In);
    cout << "加密后为：";
    for(i=0;i<8;i++)
      cout << out[i];
    cout << endl;
    //读入解密密码
    cout << "请设置解密密码：";
    c = getchar();
    for(i=0;c != '\n';i++){
      key[i] = c;
      c = getchar();
    }
    //解密演示
    memset(In,0,sizeof(In));
    cDes.createKey(key);
    cDes.Decryption(In,out);
    cout << "解密后为：";
    for(i=0;i<8;i++)
      cout << In[i];
    cout << endl;
    return 0;
}