#include <iostream>
#include <string>
#include <memory.h>
#include <cstdio>
using namespace std;
class CDES{ //定义DES类
private:
    const char IP[64] = {//初始置换
      58, 50, 42, 34, 26, 18, 10, 2,
      60, 52, 44, 36, 28, 20, 12, 4,
      62, 54, 46, 38, 30, 22, 14, 6,
      64, 56, 48, 40, 32, 24, 16, 8,
      57, 49, 41, 33, 25, 17,  9, 1,
      59, 51, 43, 35, 27, 19, 11, 3,
      61, 53, 45, 37, 29, 21, 13, 5,
      63, 55, 47, 39, 31, 23, 15, 7};
    const char EP1[56] = {//密钥置换（原64位去掉奇偶校验位后）
      57, 49, 41, 33, 25, 17,  9,
       1, 58, 50, 42, 34, 26, 18,
      10,  2, 59, 51, 43, 35, 27,
      19, 11,  3, 60, 52, 44, 36,
      63, 55, 47, 39, 31, 23, 15,
       7, 62, 54, 46, 38, 30, 22,
      14,  6, 61, 53, 45, 37, 29,
      21, 13,  5, 28, 20, 12, 4};
    const char LOOP[16] = {1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1};//左移
    const char EP2[48] = { //选择子密钥
      14, 17, 11, 24,  1,  5,
       3, 28, 15,  6, 21, 10,
      23, 19, 12,  4, 26,  8,
      16,  7, 27, 20, 13,  2,
      41, 52, 31, 37, 47, 55,
      30, 40, 51, 45, 33, 48,
      44, 49, 39, 56, 34, 53,
      46, 42, 50, 36, 29, 32};
    const char EC[48] = {//放大换位
      32,  1,  2,  3,  4,  5,
       4,  5,  6,  7,  8,  9,
       8,  9, 10, 11, 12, 13,
      12, 13, 14, 15, 16, 17,
      16, 17, 18, 19, 20, 21,
      20, 21, 22, 23, 24, 25,
      24, 25, 26, 27, 28, 29,
      28, 29, 30, 31, 32,  1};
    const char SBox[8][4][16] = {//8个S盒
      {
        // S1
        {  14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7   },
        {   0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8   },
        {   4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0   },
        {  15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13   }
      },
      {
        // S2
        {  15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10   },
        {   3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5   },
        {   0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15   },
        {  13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9   }
      },
      {
        // S3
        {  10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8   },
        {  13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1   },
        {  13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7   },
        {   1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12   }
      },
      {
        // S4
        {   7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15   },
        {  13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9   },
        {  10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4   },
        {   3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14   }
      },
      {
        // S5
        {   2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9   },
        {  14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6   },
        {   4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14   },
        {  11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3   }
      },
      {
        // S6
        {  12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11   },
        {  10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8   },
        {   9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6   },
        {   4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13   }
      },
      {
        // S7
        {   4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1   },
        {  13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6   },
        {   1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2   },
        {   6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12   }
      },
      {
        // S8
        {  13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7   },
        {   1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2   },
        {   7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8   },
        {   2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11   }
      }};
    const char PP[32] = {//P盒置换
      16,  7, 20, 21, 29, 12, 28, 17,
       1, 15, 23, 26,  5, 18, 31, 10,
       2,  8, 24, 14, 32, 27,  3,  9,
      19, 13, 30,  6, 22, 11,  4, 25};
    const char LP[64] = {//末置换
      40, 8, 48, 16, 56, 24, 64, 32,
      39, 7, 47, 15, 55, 23, 63, 31,
      38, 6, 46, 14, 54, 22, 62, 30,
      37, 5, 45, 13, 53, 21, 61, 29,
      36, 4, 44, 12, 52, 20, 60, 28,
      35, 3, 43, 11, 51, 19, 59, 27,
      34, 2, 42, 10, 50, 18, 58, 26,
      33, 1, 41,  9, 49, 17, 57, 25};
    bool M[64], tmp[32], *Li = &M[0], *Ri = &M[32];
    bool SubKey[16][48];//16个子密钥
    void f(int e){ //加密f函数，e代表加密还是解密
        int i, j;
        bool MEC[48];
        bool MS[32];
        bool MP[32];
        for(i = 0; i < 16; i++) { //16轮迭代f函数
            for(j = 0; j < 48; j++) //放大变换48位
                MEC[j] = Ri[EC[j] - 1];
          	for(j = 0; j < 48; j++){ //MEC[j]和SubKey[i][j]进行异或
            	if(e == 0) //加密
                	MEC[j] ^= SubKey[i][j];
            	else //解密
                	MEC[j] ^= SubKey[15 - i][j];
          	}
          	for(j = 0; j < 8; j++){ //S盒置换，每个S盒对应之前的每6位
            	int r, c; //r为S盒行号，c为S盒列号
            	r = MEC[j * 6] * 2 + MEC[j * 6 + 5] * 1; //计算行号，第0位第5位
            	c = MEC[j * 6 + 1] * 8 + MEC[j * 6 + 2] * 4 + MEC[j * 6 + 3] * 2 + MEC[j * 6 + 4] * 1; //计算列号，中间4位构成
            	//处理S盒结果十进制转二进制存入MP的j*4到j*4+3位
            	//比如S1盒的3，就存入MP的0到3位为 0 0 1 1
            	int ms = SBox[j][r][c]; //这是十进制的MS
				for(int k=j * 4 + 3; k >= j * 4; k--){ //转换为二进制
					MS[k] = ms % 2;
					ms /= 2;
				}
				//至此一个S盒的处理完毕，生成了4个01位在MP中
        	}
          	for(j = 0; j < 32; j++) //P盒置换
            	MP[j] = MS[PP[j] - 1];
          	//左右交换 + Li异或MP操作
          	memcpy(tmp, Ri, 32);
          	for(j = 0; j < 32; j++)
              	Ri[j] = MP[j] ^ Li[j];
         	memcpy(Li, tmp, 32);
         	if(i == 15){ //最后一轮再换回来
            	memcpy(tmp, Ri, 32);
            	memcpy(Ri, Li, 32);
            	memcpy(Li, tmp, 32);
          	}
        }
        //核心f函数执行完毕，此时M是没有经过逆置换的结果
        return;
    }
public:
    //void Mode();//模式
    void createKey(char key[8]){ //生成16组密钥
        int i, j, k;
        //将字符密钥key转换为二进制存入K
        bool K[64];
        for(i = 0; i < 8; i++){
        	K[(i + 1) * 8 - 1] = key[i] & 1;//取出0位
        	for(j = 1; j < 8; j++)
            	K[(i + 1) * 8 - 1 - j] = (key[i] >> j) & 1;//取出j位,用1做与运算掩码就行
        }
        bool KEP[56];
        for(i = 0; i < 56; i++) //EP1置换
        	KEP[i] = K[EP1[i] - 1];
        for(i = 0; i < 16; i++){ //左移Loop[i]位
          	for(j = 0; j < LOOP[i]; j++){
            	bool temp;
            	temp = KEP[0];
            	for(k = 1;k < 28; k++) //左移左侧1位
              		KEP[k - 1] = KEP[k];
            	KEP[27] = temp;
            	temp = KEP[28];
            	for(k = 29; k < 56; k++) //左移右侧1位
              		KEP[k - 1] = KEP[k];
            	KEP[55] = temp;
          	}
          	for(j = 0; j < 48; j++) //EP2形成Subkey[i]
            	SubKey[i][j] = KEP[EP2[j] - 1];
        }
        return;
    }
    void Encryption(char out[8], char In[8]){ //加密函数
        int i, j;
        //In转换为二进制存入M
        for(i = 0; i < 8; i++){
          	M[(i + 1) * 8 - 1] = In[i] & 1;//取出0位
          	for(j = 1; j < 8; j++)
            	M[(i + 1) * 8 - 1 - j] = (In[i] >> j) & 1;//取出j位,用1做与运算掩码就行
        }
        bool mTemp[64]; //64位中间变量
        memcpy(mTemp, M, 64);
        //初始置换
        for(i = 0; i < 64; i++) //IP置换
          	M[i] = mTemp[IP[i] - 1];
        f(0);//16轮f函数
        //最后针对M进行一个LP末置换
        memcpy(mTemp, M, 64);
        for(i = 0; i < 64; i++) //LP也就是IP逆置换
          	M[i] = mTemp[LP[i] - 1];
        //M转换为char存入out
        for(i = 0; i < 64; i++) //i/8代表第几个，i%8代表第几位
            out[i / 8] |= (M[i] << (7 - (i % 8))); //左移之后然后或运算
        return;
    }
    void Decryption(char out[8], char In[8]){ //解密函数
        int i, j;
        //In转换为二进制存入M
        for(i = 0; i < 8; i++){
          M[(i + 1) * 8 - 1] = In[i] & 1;//取出0位
          for(j = 1; j < 8; j++)
            M[(i + 1) * 8 - 1 - j] = (In[i] >> j) & 1;//取出j位,用1做与运算掩码就行
        }
        bool mTemp[64]; //64位中间变量
        memcpy(mTemp, M, 64);
        //初始置换
        for(i = 0; i < 64; i++) //IP置换
          M[i] = mTemp[IP[i] - 1];
        f(1);//16轮f函数
        //最后针对M进行一个LP末置换
        memcpy(mTemp, M, 64);
        for(i = 0; i < 64; i++) //LP也就是IP逆置换
          M[i] = mTemp[LP[i] - 1];
        //M转换为char存入out
        for(i = 0; i < 64; i++) //i/8代表第几个，i%8代表第几位
            out[i / 8] |= (M[i] << (7 - (i % 8))); //左移之后然后或运算
        return;
    }
};
int main(){ //主函数
    CDES cDes;
    char In[8]; memset(In, 0, sizeof(In));
    char out[8]; memset(out, 0, sizeof(out));
    char key[8]; memset(key, 0, sizeof(key));
    //读入最多8个字符
    int i; char c;
    cout << "请输入要加密的字符：";
    c = getchar();
    for(i = 0; c != '\n'; i++){
      	In[i] = c;
      	c = getchar();
    }
    //读入加密密码
    cout << "请设置加密密码：";
    c = getchar();
    for(i = 0; c != '\n'; i++){
      	key[i] = c;
      	c = getchar();
    }
    //加密演示
    cDes.createKey(key);
    cDes.Encryption(out, In);
    cout << "加密后为：";
    for(i = 0; i < 8; i++)
      	cout << out[i];
    cout << endl;
    //读入解密密码
    cout << "请设置解密密码：";
    c = getchar();
    for(i = 0; c != '\n'; i++){
      	key[i] = c;
      	c = getchar();
    }
    //解密演示
    memset(In, 0, sizeof(In));
    cDes.createKey(key);
    cDes.Decryption(In, out);
    cout << "解密后为：";
    for(i = 0; i < 8; i++)
      	cout << In[i];
    cout << endl;
    return 0;
}